{"ast":null,"code":"const express = require('express');\nconst {\n  body,\n  validationResult,\n  query\n} = require('express-validator');\nconst Store = require('../models/Store');\nconst Rating = require('../models/Rating');\nconst User = require('../models/User'); // CRITICAL IMPORT for the profile route\nconst {\n  protect\n} = require('../middleware/auth');\nconst router = express.Router();\n\n// Apply authentication to all routes\nrouter.use(protect);\n\n// @desc    Get all stores for normal users\n// @route   GET /api/user/stores\n// @access  Private (Authenticated users)\nrouter.get('/stores', [query('page').optional().isInt({\n  min: 1\n}).withMessage('Page must be a positive integer'), query('limit').optional().isInt({\n  min: 1,\n  max: 100\n}).withMessage('Limit must be between 1 and 100'), query('sortBy').optional().isIn(['name', 'address', 'averageRating', 'createdAt']).withMessage('Invalid sort field'), query('sortOrder').optional().isIn(['asc', 'desc']).withMessage('Sort order must be asc or desc'), query('search').optional().isString().withMessage('Search must be a string')], async (req, res) => {\n  try {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({\n        success: false,\n        message: 'Validation errors',\n        errors: errors.array()\n      });\n    }\n    const page = parseInt(req.query.page) || 1;\n    const limit = parseInt(req.query.limit) || 10;\n    const sortBy = req.query.sortBy || 'createdAt';\n    const sortOrder = req.query.sortOrder === 'asc' ? 1 : -1;\n    const search = req.query.search;\n\n    // Build filter object - only show active stores\n    let filter = {\n      isActive: true\n    };\n    if (search) {\n      filter.$or = [{\n        name: {\n          $regex: search,\n          $options: 'i'\n        }\n      }, {\n        address: {\n          $regex: search,\n          $options: 'i'\n        }\n      }];\n    }\n    let stores;\n    let total;\n    if (sortBy === 'averageRating') {\n      // 1. Get total count first (requires matching but not skipping/limiting)\n      const totalCountPipeline = [{\n        $match: filter\n      }, {\n        $count: \"total\"\n      }];\n      const totalResult = await Store.aggregate(totalCountPipeline);\n      total = totalResult.length > 0 ? totalResult[0].total : 0;\n\n      // 2. Use aggregation for sorting by calculated average rating\n      stores = await Store.aggregate([{\n        $match: filter\n      }, {\n        $lookup: {\n          from: 'ratings',\n          localField: '_id',\n          foreignField: 'store',\n          as: 'ratings'\n        }\n      }, {\n        $addFields: {\n          averageRating: {\n            $cond: {\n              if: {\n                $gt: [{\n                  $size: '$ratings'\n                }, 0]\n              },\n              then: {\n                $avg: '$ratings.rating'\n              },\n              else: 0\n            }\n          },\n          totalRatings: {\n            $size: '$ratings'\n          }\n        }\n      },\n      // Sort, skip, and limit operations\n      {\n        $sort: {\n          averageRating: sortOrder\n        }\n      }, {\n        $skip: skip\n      }, {\n        $limit: limit\n      },\n      // Populate owner info (must be done via $lookup since we are in aggregation pipeline)\n      {\n        $lookup: {\n          from: 'users',\n          localField: 'owner',\n          foreignField: '_id',\n          as: 'owner'\n        }\n      }, {\n        $unwind: {\n          path: '$owner',\n          preserveNullAndEmptyArrays: true\n        }\n      }, {\n        $project: {\n          ratings: 0,\n          // Exclude raw ratings array\n          'owner.password': 0 // Exclude owner's password\n        }\n      }]);\n    } else {\n      // 2. Standard find for other sorts (name, createdAt, etc.)\n      stores = await Store.find(filter).sort({\n        [sortBy]: sortOrder\n      }).skip(skip).limit(limit).populate('owner', 'name email').lean();\n\n      // 1. Get total count\n      total = await Store.countDocuments(filter);\n\n      // If not sorted by averageRating, calculate ratings separately\n      const storeIds = stores.map(store => store._id);\n      const averageRatings = await Rating.aggregate([{\n        $match: {\n          store: {\n            $in: storeIds\n          }\n        }\n      }, {\n        $group: {\n          _id: '$store',\n          averageRating: {\n            $avg: '$rating'\n          },\n          totalRatings: {\n            $sum: 1\n          }\n        }\n      }]);\n      const averageRatingsMap = {};\n      averageRatings.forEach(rating => {\n        averageRatingsMap[rating._id.toString()] = {\n          averageRating: Math.round(rating.averageRating * 10) / 10,\n          totalRatings: rating.totalRatings\n        };\n      });\n\n      // Add calculated ratings to stores\n      stores = stores.map(store => {\n        var _averageRatingsMap$st, _averageRatingsMap$st2;\n        return {\n          ...store,\n          averageRating: ((_averageRatingsMap$st = averageRatingsMap[store._id.toString()]) === null || _averageRatingsMap$st === void 0 ? void 0 : _averageRatingsMap$st.averageRating) || 0,\n          totalRatings: ((_averageRatingsMap$st2 = averageRatingsMap[store._id.toString()]) === null || _averageRatingsMap$st2 === void 0 ? void 0 : _averageRatingsMap$st2.totalRatings) || 0\n        };\n      });\n    }\n\n    // --- Add User's Specific Rating ---\n\n    // Get the stores currently being displayed\n    const currentStoreIds = stores.map(store => store._id);\n\n    // Find the current user's ratings for these stores\n    const userRatings = await Rating.find({\n      user: req.user.id,\n      store: {\n        $in: currentStoreIds\n      }\n    }).lean();\n    const userRatingsMap = {};\n    userRatings.forEach(rating => {\n      userRatingsMap[rating.store.toString()] = rating;\n    });\n\n    // Final mapping: Combine store data with user's specific rating\n    const storesWithRatings = stores.map(store => ({\n      ...store,\n      // Ensure averageRating is rounded correctly for aggregated results path\n      averageRating: Math.round((store.averageRating || 0) * 10) / 10,\n      userRating: userRatingsMap[store._id.toString()] || null\n    }));\n    res.json({\n      success: true,\n      data: {\n        stores: storesWithRatings,\n        pagination: {\n          currentPage: page,\n          totalPages: Math.ceil(total / limit),\n          totalStores: total,\n          hasNextPage: page < Math.ceil(total / limit),\n          hasPrevPage: page > 1\n        }\n      }\n    });\n  } catch (error) {\n    console.error('Get stores error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Server error',\n      error: error.message\n    });\n  }\n});\n\n// @desc    Submit or update rating for a store\n// @route   POST /api/user/stores/:storeId/rate\n// @access  Private (Authenticated users)\nrouter.post('/stores/:storeId/rate', [body('rating').isInt({\n  min: 1,\n  max: 5\n}).withMessage('Rating must be an integer between 1 and 5'), body('review').optional().isLength({\n  max: 500\n}).withMessage('Review cannot exceed 500 characters')], async (req, res) => {\n  try {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({\n        success: false,\n        message: 'Validation errors',\n        errors: errors.array()\n      });\n    }\n    const {\n      rating,\n      review\n    } = req.body;\n    const storeId = req.params.storeId;\n\n    // Validate MongoDB ObjectId\n    if (!storeId.match(/^[0-9a-fA-F]{24}$/)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid store ID format'\n      });\n    }\n\n    // Check if store exists and is active\n    const store = await Store.findById(storeId);\n    if (!store || !store.isActive) {\n      return res.status(404).json({\n        success: false,\n        message: 'Store not found or is not active'\n      });\n    }\n\n    // Check if user already rated this store\n    const existingRating = await Rating.findOne({\n      user: req.user.id,\n      store: storeId\n    });\n    let ratingDoc;\n    let message;\n    if (existingRating) {\n      // Update existing rating\n      existingRating.rating = rating;\n      if (review !== undefined) {\n        existingRating.review = review;\n      }\n      ratingDoc = await existingRating.save();\n      message = 'Rating updated successfully';\n    } else {\n      // Create new rating\n      ratingDoc = await Rating.create({\n        user: req.user.id,\n        store: storeId,\n        rating,\n        review: review || ''\n      });\n      message = 'Rating submitted successfully';\n    }\n\n    // Populate the rating with user and store info\n    await ratingDoc.populate([{\n      path: 'user',\n      select: 'name email'\n    }, {\n      path: 'store',\n      select: 'name email address'\n    }]);\n    res.json({\n      success: true,\n      message,\n      data: ratingDoc\n    });\n  } catch (error) {\n    console.error('Rate store error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Server error',\n      error: error.message\n    });\n  }\n});\n\n// @desc    Get user's ratings\n// @route   GET /api/user/ratings\n// @access  Private (Authenticated users)\nrouter.get('/ratings', [query('page').optional().isInt({\n  min: 1\n}).withMessage('Page must be a positive integer'), query('limit').optional().isInt({\n  min: 1,\n  max: 100\n}).withMessage('Limit must be between 1 and 100'), query('sortBy').optional().isIn(['rating', 'createdAt', 'updatedAt']).withMessage('Invalid sort field'), query('sortOrder').optional().isIn(['asc', 'desc']).withMessage('Sort order must be asc or desc')], async (req, res) => {\n  try {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({\n        success: false,\n        message: 'Validation errors',\n        errors: errors.array()\n      });\n    }\n    const page = parseInt(req.query.page) || 1;\n    const limit = parseInt(req.query.limit) || 10;\n    const sortBy = req.query.sortBy || 'createdAt';\n    const sortOrder = req.query.sortOrder === 'asc' ? 1 : -1;\n\n    // Calculate pagination\n    const skip = (page - 1) * limit;\n\n    // Get user's ratings with pagination and sorting\n    const ratings = await Rating.find({\n      user: req.user.id\n    }).sort({\n      [sortBy]: sortOrder\n    }).skip(skip).limit(limit).populate('store', 'name email address').lean();\n\n    // Get total count\n    const total = await Rating.countDocuments({\n      user: req.user.id\n    });\n    res.json({\n      success: true,\n      data: {\n        ratings,\n        pagination: {\n          currentPage: page,\n          totalPages: Math.ceil(total / limit),\n          totalRatings: total,\n          hasNextPage: page < Math.ceil(total / limit),\n          hasPrevPage: page > 1\n        }\n      }\n    });\n  } catch (error) {\n    console.error('Get user ratings error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Server error',\n      error: error.message\n    });\n  }\n});\n\n// @desc    Delete user's rating\n// @route   DELETE /api/user/ratings/:ratingId\n// @access  Private (Authenticated users)\nrouter.delete('/ratings/:ratingId', async (req, res) => {\n  try {\n    // Validate MongoDB ObjectId\n    if (!req.params.ratingId.match(/^[0-9a-fA-F]{24}$/)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid rating ID format'\n      });\n    }\n    const rating = await Rating.findOne({\n      _id: req.params.ratingId,\n      user: req.user.id\n    });\n    if (!rating) {\n      return res.status(404).json({\n        success: false,\n        message: 'Rating not found or you do not have permission to delete it'\n      });\n    }\n    await Rating.findByIdAndDelete(rating._id);\n    res.json({\n      success: true,\n      message: 'Rating deleted successfully'\n    });\n  } catch (error) {\n    console.error('Delete rating error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Server error',\n      error: error.message\n    });\n  }\n});\n\n// @desc    Get store details with user's rating\n// @route   GET /api/user/stores/:storeId\n// @access  Private (Authenticated users)\nrouter.get('/stores/:storeId', async (req, res) => {\n  try {\n    // Validate MongoDB ObjectId\n    if (!req.params.storeId.match(/^[0-9a-fA-F]{24}$/)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid store ID format'\n      });\n    }\n    const store = await Store.findById(req.params.storeId).populate('owner', 'name email').lean();\n    if (!store) {\n      return res.status(404).json({\n        success: false,\n        message: 'Store not found'\n      });\n    }\n    if (!store.isActive) {\n      return res.status(400).json({\n        success: false,\n        message: 'Store is not active'\n      });\n    }\n\n    // Get user's rating for this store\n    const userRating = await Rating.findOne({\n      user: req.user.id,\n      store: store._id\n    }).lean();\n\n    // Get average rating and total ratings\n    const ratingStats = await Rating.aggregate([{\n      $match: {\n        store: store._id\n      }\n    }, {\n      $group: {\n        _id: '$store',\n        averageRating: {\n          $avg: '$rating'\n        },\n        totalRatings: {\n          $sum: 1\n        }\n      }\n    }]);\n\n    // Get all ratings for this store with user details\n    const allRatings = await Rating.find({\n      store: store._id\n    }).populate('user', 'name email').sort({\n      createdAt: -1\n    }).limit(10).lean();\n    const storeWithRatings = {\n      ...store,\n      userRating,\n      averageRating: ratingStats.length > 0 ? Math.round(ratingStats[0].averageRating * 10) / 10 : 0,\n      totalRatings: ratingStats.length > 0 ? ratingStats[0].totalRatings : 0,\n      recentRatings: allRatings\n    };\n    res.json({\n      success: true,\n      data: storeWithRatings\n    });\n  } catch (error) {\n    console.error('Get store details error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Server error',\n      error: error.message\n    });\n  }\n});\n\n// @desc    Get user profile\n// @route   GET /api/user/profile\n// @access  Private (Authenticated users)\nrouter.get('/profile', async (req, res) => {\n  try {\n    // Fetch the full user object using the ID attached by the 'protect' middleware\n    const user = await User.findById(req.user.id).select('-password').lean();\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'User not found'\n      });\n    }\n\n    // Get user's rating statistics\n    const ratingCount = await Rating.countDocuments({\n      user: user._id\n    });\n    const userRatings = await Rating.find({\n      user: user._id\n    }).populate('store', 'name email').sort({\n      createdAt: -1\n    }).limit(5).lean();\n    res.json({\n      success: true,\n      data: {\n        user: {\n          id: user._id,\n          name: user.name,\n          email: user.email,\n          address: user.address,\n          role: user.role,\n          createdAt: user.createdAt\n        },\n        statistics: {\n          totalRatings: ratingCount\n        },\n        recentRatings: userRatings\n      }\n    });\n  } catch (error) {\n    console.error('Get profile error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Server error',\n      error: error.message\n    });\n  }\n});\nmodule.exports = router;","map":{"version":3,"names":["express","require","body","validationResult","query","Store","Rating","User","protect","router","Router","use","get","optional","isInt","min","withMessage","max","isIn","isString","req","res","errors","isEmpty","status","json","success","message","array","page","parseInt","limit","sortBy","sortOrder","search","filter","isActive","$or","name","$regex","$options","address","stores","total","totalCountPipeline","$match","$count","totalResult","aggregate","length","$lookup","from","localField","foreignField","as","$addFields","averageRating","$cond","if","$gt","$size","then","$avg","else","totalRatings","$sort","$skip","skip","$limit","$unwind","path","preserveNullAndEmptyArrays","$project","ratings","find","sort","populate","lean","countDocuments","storeIds","map","store","_id","averageRatings","$in","$group","$sum","averageRatingsMap","forEach","rating","toString","Math","round","_averageRatingsMap$st","_averageRatingsMap$st2","currentStoreIds","userRatings","user","id","userRatingsMap","storesWithRatings","userRating","data","pagination","currentPage","totalPages","ceil","totalStores","hasNextPage","hasPrevPage","error","console","post","isLength","review","storeId","params","match","findById","existingRating","findOne","ratingDoc","undefined","save","create","select","delete","ratingId","findByIdAndDelete","ratingStats","allRatings","createdAt","storeWithRatings","recentRatings","ratingCount","email","role","statistics","module","exports"],"sources":["C:/Users/ay982/OneDrive/Desktop/Assignment/client/src/components/user/UserStores.js"],"sourcesContent":["const express = require('express');\r\nconst { body, validationResult, query } = require('express-validator');\r\nconst Store = require('../models/Store');\r\nconst Rating = require('../models/Rating');\r\nconst User = require('../models/User'); // CRITICAL IMPORT for the profile route\r\nconst { protect } = require('../middleware/auth');\r\n\r\nconst router = express.Router();\r\n\r\n// Apply authentication to all routes\r\nrouter.use(protect);\r\n\r\n// @desc    Get all stores for normal users\r\n// @route   GET /api/user/stores\r\n// @access  Private (Authenticated users)\r\nrouter.get('/stores', [\r\n  query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),\r\n  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'),\r\n  query('sortBy').optional().isIn(['name', 'address', 'averageRating', 'createdAt']).withMessage('Invalid sort field'),\r\n  query('sortOrder').optional().isIn(['asc', 'desc']).withMessage('Sort order must be asc or desc'),\r\n  query('search').optional().isString().withMessage('Search must be a string')\r\n], async (req, res) => {\r\n  try {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Validation errors',\r\n        errors: errors.array()\r\n      });\r\n    }\r\n\r\n    const page = parseInt(req.query.page) || 1;\r\n    const limit = parseInt(req.query.limit) || 10;\r\n    const sortBy = req.query.sortBy || 'createdAt';\r\n    const sortOrder = req.query.sortOrder === 'asc' ? 1 : -1;\r\n    const search = req.query.search;\r\n\r\n    // Build filter object - only show active stores\r\n    let filter = { isActive: true };\r\n\r\n    if (search) {\r\n      filter.$or = [\r\n        { name: { $regex: search, $options: 'i' } },\r\n        { address: { $regex: search, $options: 'i' } }\r\n      ];\r\n    }\r\n\r\n    let stores;\r\n    let total;\r\n\r\n    if (sortBy === 'averageRating') {\r\n      // 1. Get total count first (requires matching but not skipping/limiting)\r\n      const totalCountPipeline = [\r\n        { $match: filter },\r\n        { $count: \"total\" }\r\n      ];\r\n      const totalResult = await Store.aggregate(totalCountPipeline);\r\n      total = totalResult.length > 0 ? totalResult[0].total : 0;\r\n\r\n      // 2. Use aggregation for sorting by calculated average rating\r\n      stores = await Store.aggregate([\r\n        { $match: filter },\r\n        {\r\n          $lookup: {\r\n            from: 'ratings',\r\n            localField: '_id',\r\n            foreignField: 'store',\r\n            as: 'ratings'\r\n          }\r\n        },\r\n        {\r\n          $addFields: {\r\n            averageRating: {\r\n              $cond: {\r\n                if: { $gt: [{ $size: '$ratings' }, 0] },\r\n                then: { $avg: '$ratings.rating' },\r\n                else: 0\r\n              }\r\n            },\r\n            totalRatings: { $size: '$ratings' }\r\n          }\r\n        },\r\n        // Sort, skip, and limit operations\r\n        { $sort: { averageRating: sortOrder } },\r\n        { $skip: skip },\r\n        { $limit: limit },\r\n        // Populate owner info (must be done via $lookup since we are in aggregation pipeline)\r\n        {\r\n          $lookup: {\r\n            from: 'users',\r\n            localField: 'owner',\r\n            foreignField: '_id',\r\n            as: 'owner'\r\n          }\r\n        },\r\n        { $unwind: { path: '$owner', preserveNullAndEmptyArrays: true } },\r\n        {\r\n          $project: {\r\n            ratings: 0, // Exclude raw ratings array\r\n            'owner.password': 0 // Exclude owner's password\r\n          }\r\n        }\r\n      ]);\r\n      \r\n    } else {\r\n      // 2. Standard find for other sorts (name, createdAt, etc.)\r\n      stores = await Store.find(filter)\r\n        .sort({ [sortBy]: sortOrder })\r\n        .skip(skip)\r\n        .limit(limit)\r\n        .populate('owner', 'name email')\r\n        .lean();\r\n\r\n      // 1. Get total count\r\n      total = await Store.countDocuments(filter);\r\n      \r\n      // If not sorted by averageRating, calculate ratings separately\r\n      const storeIds = stores.map(store => store._id);\r\n      const averageRatings = await Rating.aggregate([\r\n        { $match: { store: { $in: storeIds } } },\r\n        {\r\n          $group: {\r\n            _id: '$store',\r\n            averageRating: { $avg: '$rating' },\r\n            totalRatings: { $sum: 1 }\r\n          }\r\n        }\r\n      ]);\r\n\r\n      const averageRatingsMap = {};\r\n      averageRatings.forEach(rating => {\r\n        averageRatingsMap[rating._id.toString()] = {\r\n          averageRating: Math.round(rating.averageRating * 10) / 10,\r\n          totalRatings: rating.totalRatings\r\n        };\r\n      });\r\n\r\n      // Add calculated ratings to stores\r\n      stores = stores.map(store => ({\r\n        ...store,\r\n        averageRating: averageRatingsMap[store._id.toString()]?.averageRating || 0,\r\n        totalRatings: averageRatingsMap[store._id.toString()]?.totalRatings || 0\r\n      }));\r\n    }\r\n\r\n    // --- Add User's Specific Rating ---\r\n\r\n    // Get the stores currently being displayed\r\n    const currentStoreIds = stores.map(store => store._id);\r\n    \r\n    // Find the current user's ratings for these stores\r\n    const userRatings = await Rating.find({\r\n      user: req.user.id,\r\n      store: { $in: currentStoreIds }\r\n    }).lean();\r\n\r\n    const userRatingsMap = {};\r\n    userRatings.forEach(rating => {\r\n      userRatingsMap[rating.store.toString()] = rating;\r\n    });\r\n\r\n    // Final mapping: Combine store data with user's specific rating\r\n    const storesWithRatings = stores.map(store => ({\r\n      ...store,\r\n      // Ensure averageRating is rounded correctly for aggregated results path\r\n      averageRating: Math.round((store.averageRating || 0) * 10) / 10,\r\n      userRating: userRatingsMap[store._id.toString()] || null\r\n    }));\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        stores: storesWithRatings,\r\n        pagination: {\r\n          currentPage: page,\r\n          totalPages: Math.ceil(total / limit),\r\n          totalStores: total,\r\n          hasNextPage: page < Math.ceil(total / limit),\r\n          hasPrevPage: page > 1\r\n        }\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Get stores error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Server error',\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// @desc    Submit or update rating for a store\r\n// @route   POST /api/user/stores/:storeId/rate\r\n// @access  Private (Authenticated users)\r\nrouter.post('/stores/:storeId/rate', [\r\n  body('rating')\r\n    .isInt({ min: 1, max: 5 })\r\n    .withMessage('Rating must be an integer between 1 and 5'),\r\n  body('review')\r\n    .optional()\r\n    .isLength({ max: 500 })\r\n    .withMessage('Review cannot exceed 500 characters')\r\n], async (req, res) => {\r\n  try {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Validation errors',\r\n        errors: errors.array()\r\n      });\r\n    }\r\n\r\n    const { rating, review } = req.body;\r\n    const storeId = req.params.storeId;\r\n\r\n    // Validate MongoDB ObjectId\r\n    if (!storeId.match(/^[0-9a-fA-F]{24}$/)) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Invalid store ID format'\r\n      });\r\n    }\r\n\r\n    // Check if store exists and is active\r\n    const store = await Store.findById(storeId);\r\n    if (!store || !store.isActive) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Store not found or is not active'\r\n      });\r\n    }\r\n\r\n    // Check if user already rated this store\r\n    const existingRating = await Rating.findOne({\r\n      user: req.user.id,\r\n      store: storeId\r\n    });\r\n\r\n    let ratingDoc;\r\n    let message;\r\n\r\n    if (existingRating) {\r\n      // Update existing rating\r\n      existingRating.rating = rating;\r\n      if (review !== undefined) {\r\n        existingRating.review = review;\r\n      }\r\n      ratingDoc = await existingRating.save();\r\n      message = 'Rating updated successfully';\r\n    } else {\r\n      // Create new rating\r\n      ratingDoc = await Rating.create({\r\n        user: req.user.id,\r\n        store: storeId,\r\n        rating,\r\n        review: review || ''\r\n      });\r\n      message = 'Rating submitted successfully';\r\n    }\r\n\r\n    // Populate the rating with user and store info\r\n    await ratingDoc.populate([\r\n      { path: 'user', select: 'name email' },\r\n      { path: 'store', select: 'name email address' }\r\n    ]);\r\n\r\n    res.json({\r\n      success: true,\r\n      message,\r\n      data: ratingDoc\r\n    });\r\n  } catch (error) {\r\n    console.error('Rate store error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Server error',\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// @desc    Get user's ratings\r\n// @route   GET /api/user/ratings\r\n// @access  Private (Authenticated users)\r\nrouter.get('/ratings', [\r\n  query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),\r\n  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'),\r\n  query('sortBy').optional().isIn(['rating', 'createdAt', 'updatedAt']).withMessage('Invalid sort field'),\r\n  query('sortOrder').optional().isIn(['asc', 'desc']).withMessage('Sort order must be asc or desc')\r\n], async (req, res) => {\r\n  try {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Validation errors',\r\n        errors: errors.array()\r\n      });\r\n    }\r\n\r\n    const page = parseInt(req.query.page) || 1;\r\n    const limit = parseInt(req.query.limit) || 10;\r\n    const sortBy = req.query.sortBy || 'createdAt';\r\n    const sortOrder = req.query.sortOrder === 'asc' ? 1 : -1;\r\n\r\n    // Calculate pagination\r\n    const skip = (page - 1) * limit;\r\n\r\n    // Get user's ratings with pagination and sorting\r\n    const ratings = await Rating.find({ user: req.user.id })\r\n      .sort({ [sortBy]: sortOrder })\r\n      .skip(skip)\r\n      .limit(limit)\r\n      .populate('store', 'name email address')\r\n      .lean();\r\n\r\n    // Get total count\r\n    const total = await Rating.countDocuments({ user: req.user.id });\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        ratings,\r\n        pagination: {\r\n          currentPage: page,\r\n          totalPages: Math.ceil(total / limit),\r\n          totalRatings: total,\r\n          hasNextPage: page < Math.ceil(total / limit),\r\n          hasPrevPage: page > 1\r\n        }\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Get user ratings error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Server error',\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// @desc    Delete user's rating\r\n// @route   DELETE /api/user/ratings/:ratingId\r\n// @access  Private (Authenticated users)\r\nrouter.delete('/ratings/:ratingId', async (req, res) => {\r\n  try {\r\n    // Validate MongoDB ObjectId\r\n    if (!req.params.ratingId.match(/^[0-9a-fA-F]{24}$/)) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Invalid rating ID format'\r\n      });\r\n    }\r\n\r\n    const rating = await Rating.findOne({\r\n      _id: req.params.ratingId,\r\n      user: req.user.id\r\n    });\r\n\r\n    if (!rating) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Rating not found or you do not have permission to delete it'\r\n      });\r\n    }\r\n\r\n    await Rating.findByIdAndDelete(rating._id);\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Rating deleted successfully'\r\n    });\r\n  } catch (error) {\r\n    console.error('Delete rating error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Server error',\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// @desc    Get store details with user's rating\r\n// @route   GET /api/user/stores/:storeId\r\n// @access  Private (Authenticated users)\r\nrouter.get('/stores/:storeId', async (req, res) => {\r\n  try {\r\n    // Validate MongoDB ObjectId\r\n    if (!req.params.storeId.match(/^[0-9a-fA-F]{24}$/)) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Invalid store ID format'\r\n      });\r\n    }\r\n\r\n    const store = await Store.findById(req.params.storeId)\r\n      .populate('owner', 'name email')\r\n      .lean();\r\n\r\n    if (!store) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Store not found'\r\n      });\r\n    }\r\n\r\n    if (!store.isActive) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Store is not active'\r\n      });\r\n    }\r\n\r\n    // Get user's rating for this store\r\n    const userRating = await Rating.findOne({\r\n      user: req.user.id,\r\n      store: store._id\r\n    }).lean();\r\n\r\n    // Get average rating and total ratings\r\n    const ratingStats = await Rating.aggregate([\r\n      { $match: { store: store._id } },\r\n      {\r\n        $group: {\r\n          _id: '$store',\r\n          averageRating: { $avg: '$rating' },\r\n          totalRatings: { $sum: 1 }\r\n        }\r\n      }\r\n    ]);\r\n\r\n    // Get all ratings for this store with user details\r\n    const allRatings = await Rating.find({ store: store._id })\r\n      .populate('user', 'name email')\r\n      .sort({ createdAt: -1 })\r\n      .limit(10)\r\n      .lean();\r\n\r\n    const storeWithRatings = {\r\n      ...store,\r\n      userRating,\r\n      averageRating: ratingStats.length > 0 ? Math.round(ratingStats[0].averageRating * 10) / 10 : 0,\r\n      totalRatings: ratingStats.length > 0 ? ratingStats[0].totalRatings : 0,\r\n      recentRatings: allRatings\r\n    };\r\n\r\n    res.json({\r\n      success: true,\r\n      data: storeWithRatings\r\n    });\r\n  } catch (error) {\r\n    console.error('Get store details error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Server error',\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// @desc    Get user profile\r\n// @route   GET /api/user/profile\r\n// @access  Private (Authenticated users)\r\nrouter.get('/profile', async (req, res) => {\r\n  try {\r\n    // Fetch the full user object using the ID attached by the 'protect' middleware\r\n    const user = await User.findById(req.user.id).select('-password').lean(); \r\n\r\n    if (!user) {\r\n        return res.status(404).json({ success: false, message: 'User not found' });\r\n    }\r\n\r\n    // Get user's rating statistics\r\n    const ratingCount = await Rating.countDocuments({ user: user._id });\r\n    const userRatings = await Rating.find({ user: user._id })\r\n      .populate('store', 'name email')\r\n      .sort({ createdAt: -1 })\r\n      .limit(5)\r\n      .lean();\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        user: {\r\n          id: user._id,\r\n          name: user.name,\r\n          email: user.email,\r\n          address: user.address,\r\n          role: user.role,\r\n          createdAt: user.createdAt\r\n        },\r\n        statistics: {\r\n          totalRatings: ratingCount\r\n        },\r\n        recentRatings: userRatings\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Get profile error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Server error',\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\nmodule.exports = router;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}